#!/bin/sh

set -eu

run_in_sysroot() {
  sysroot="$1"
  shift

  # Alpine installs LLVM in versioned directories `/usr/lib/llvm<version>`.
  # Find the latest one.
  llvm_dir=$(ls -d "${sysroot}/usr/lib/llvm"* | sort -V | tail -n1)
  llvm_dir=${llvm_dir#"$sysroot"}

  # To make the compile tests work in the sysroot, adjust `RUSTUP_TOOLCHAIN` to
  # to point to the musl equivalent of the requested toolchain.
  if [ -n "${RUSTUP_TOOLCHAIN-}" ]; then
    export RUSTUP_TOOLCHAIN=${RUSTUP_TOOLCHAIN%-*}-musl
  fi

  # Use bubblewrap to create and enter a rootless container based on the given
  # sysroot.
  #
  # Let bubblewrap mount new procfs and devfs.
  #
  # Bind mount the current working directory in read-write mode so the tools can
  # work inside the repo.
  #
  # Bind mount DNS-related configuration, otherwise the wrapped processes would
  # not be able to resolve domains.
  #
  # Bind mount /tmp from host, because doctests (that we run inside the
  # container) need the /tmp/rustdoctest* files (generated by Cargo on host).
  #
  # Set the correct environment (PATH, USER, HOME etc.), since in the most
  # cases we are not executing a login shell.
  #
  # Unset CARGO and RUSTC that would mess up with execution of compile tests
  # (they would try to execute rustc based on the path provided by host).
  bwrap \
    --unshare-user --uid 0 --gid 0 \
    --unshare-pid --unshare-ipc --unshare-uts \
    --bind "${sysroot}" / \
    --proc /proc \
    --dev /dev \
    --bind "$(pwd)" "$(pwd)" \
    --chdir "$(pwd)" \
    --ro-bind /etc/hosts /etc/hosts \
    --ro-bind /etc/resolv.conf /etc/resolv.conf \
    --bind /tmp /tmp \
    --setenv USER root \
    --setenv HOME /root \
    --setenv CARGO_HOME /root/.cargo \
    --setenv RUSTUP_HOME /root/.rustup \
    --setenv PATH "/root/.cargo/bin:${llvm_dir}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" \
    --unsetenv CARGO \
    --unsetenv RUSTC \
    "$@"
}

exec_compiler() {
  compiler="$1"
  target="$2"
  sysroot="$3"
  shift 3

  # Enforce lld as a linker, it allows linking objects built for other
  # architectures without additional wrappers.
  #
  # With the default option of using GNU linker, clang would first try to find
  # a wrapper, then fall back to searching for a linker in the sysroot, which
  # then would fail to execute (as it's a foreign binary).
  exec "${compiler}" \
    "--target=${target}" \
    "--sysroot=${sysroot}" \
    -fuse-ld=lld \
    "$@"
}
